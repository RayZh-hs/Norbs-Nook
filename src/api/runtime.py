"""
- src/api/runtime.py

A library for handling the wui_runtime executable generated by cpp.

The runtime can be compiled with CMake, using the CMake executable: wui_runtime.

The compiled runtime will by default be at src/api/builds/wui_runtime.
"""

import subprocess
import time         # A little delay for the runtime to react shouldn't hurt.
import logging

from public import *
logger = logging.getLogger(__name__)

class Runtime:
    def __init__(self, runtime_path: str):
        self.runtime_path = runtime_path
        self.process = None
        self.lock = False
    
    def start(self):
        if self.process is not None:
            raise RuntimeError("Runtime is already running.")
        self.process = subprocess.Popen(
            [self.runtime_path],
            stdin  = subprocess.PIPE,
            stdout = subprocess.PIPE,
            stderr = subprocess.PIPE,
            text   = True
        )
    
    def end(self):
        if self.process is None:
            raise RuntimeError("Runtime is not running.")
        try:
            self.process.stdin.write("exit\n")
            self.process.stdin.flush()
            self.process.wait(timeout=3)
        except subprocess.TimeoutExpired:
            self.process.kill()
        self.process = None
    
    def write(self, data: str):
        if self.process is None:
            raise RuntimeError("Runtime is not running.")
        self.process.stdin.write(data)
        self.process.stdin.flush()
    
    def read_line(self):
        if self.process is None:
            raise RuntimeError("Runtime is not running.")
        return self.process.stdout.readline()

    def read(self):
        if self.process is None:
            raise RuntimeError("Runtime is not running.")
        return self.process.stdout.read()
    
    def query(self, data: str):
        while self.lock:
            time.sleep(0.1)
        self.lock = True
        logger.log(logging.DEBUG, "Lock acquired.")
        logger.log(logging.INFO, f"Querying runtime with: {data}")
        if self.process is None:
            raise RuntimeError("Runtime is not running.")
        self.write(data)
        logger.log(logging.INFO, "Sent data; Waiting for response...")
        try:
            line = ""
            while not line:
                line = self.read_line()
                time.sleep(0.1)
            logger.log(logging.INFO, f"Received response: {line}".strip())
            self.lock = False
            logger.log(logging.DEBUG, "Lock released.")
            return line
        except subprocess.TimeoutExpired:
            logger.log(logging.ERROR, "Query timed out.")
            self.lock = False
            logger.log(logging.DEBUG, "Lock released.")
            raise TimeoutError("Query timed out.")